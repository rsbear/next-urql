{"ast":null,"code":"import _Object$defineProperty from \"@babel/runtime-corejs2/core-js/object/define-property\";\nimport _Object$defineProperties from \"@babel/runtime-corejs2/core-js/object/define-properties\";\nimport _Object$getOwnPropertyDescriptors from \"@babel/runtime-corejs2/core-js/object/get-own-property-descriptors\";\nimport _Object$getOwnPropertyDescriptor from \"@babel/runtime-corejs2/core-js/object/get-own-property-descriptor\";\nimport _Object$getOwnPropertySymbols from \"@babel/runtime-corejs2/core-js/object/get-own-property-symbols\";\nimport _Object$keys from \"@babel/runtime-corejs2/core-js/object/keys\";\nimport _defineProperty from \"@babel/runtime-corejs2/helpers/esm/defineProperty\";\nimport _extends from \"@babel/runtime-corejs2/helpers/esm/extends\";\nvar _jsxFileName = \"/Users/rsbear/dev/next-urql/lib/withUrqlClient.tsx\";\nvar __jsx = React.createElement;\n\nfunction ownKeys(object, enumerableOnly) { var keys = _Object$keys(object); if (_Object$getOwnPropertySymbols) { var symbols = _Object$getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return _Object$getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }\n\nfunction _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(Object(source), true).forEach(function (key) { _defineProperty(target, key, source[key]); }); } else if (_Object$getOwnPropertyDescriptors) { _Object$defineProperties(target, _Object$getOwnPropertyDescriptors(source)); } else { ownKeys(Object(source)).forEach(function (key) { _Object$defineProperty(target, key, _Object$getOwnPropertyDescriptor(source, key)); }); } } return target; }\n\nimport React from \"react\";\nimport { Provider } from \"urql\";\nimport cookie from \"cookie\";\nimport ssrPrepass from \"react-ssr-prepass\";\nimport initUrqlClient from \"./initUrql\";\nimport { useAuthUserQuery } from \"../generated/graphql\";\nconst isBrowser = false;\n\nconst withUrqlClient = App => {\n  const withUrql = props => {\n    const [{\n      fetching,\n      error,\n      data\n    }] = useAuthUserQuery();\n    const urqlClient = props.urqlClient || initUrqlClient(props.urqlState, props.serverAccessToken)[0];\n    const authUser = !fetching && data && data.me ? data.me : null;\n    return __jsx(Provider, {\n      value: urqlClient,\n      __source: {\n        fileName: _jsxFileName,\n        lineNumber: 19\n      },\n      __self: this\n    }, __jsx(App, _extends({}, props, {\n      urqlClient: urqlClient,\n      authUser: authUser,\n      __source: {\n        fileName: _jsxFileName,\n        lineNumber: 20\n      },\n      __self: this\n    })));\n  };\n\n  withUrql.getInitialProps = async ctx => {\n    const {\n      AppTree\n    } = ctx;\n    const {\n      req,\n      res\n    } = ctx; // Run the wrapped component's getInitialProps function\n\n    let appProps = {};\n    if (App.getInitialProps) appProps = await App.getInitialProps(ctx); // getInitialProps is universal, but we only want\n    // to run server-side rendered suspense on the server\n\n    let serverAccessToken = \"\";\n\n    if (!isBrowser) {\n      const cookies = cookie.parse(req.headers.cookie ? req.headers.cookie : \"\");\n\n      if (cookies.rfs) {\n        const response = await fetch(\"http://localhost:4000/refresh_token\", {\n          method: \"POST\",\n          credentials: \"include\",\n          headers: {\n            cookie: \"rfs=\" + cookies.rfs\n          }\n        });\n        const data = await response.json();\n        serverAccessToken = data.accessToken;\n      }\n    }\n\n    if (isBrowser) return appProps;\n    const [urqlClient, ssrCache] = initUrqlClient({}, serverAccessToken); // Run suspense and hence all urql queries\n\n    try {\n      await ssrPrepass(__jsx(AppTree, {\n        pageProps: _objectSpread({}, appProps, {\n          urqlClient\n        }),\n        __source: {\n          fileName: _jsxFileName,\n          lineNumber: 60\n        },\n        __self: this\n      }));\n    } catch (err) {\n      console.log(err);\n    } // Extract query data from the urql store\n    // Extract the SSR query data from urql's SSR cache\n\n\n    const urqlState = ssrCache.extractData();\n    return _objectSpread({}, appProps, {\n      urqlState,\n      serverAccessToken\n    });\n  };\n\n  return withUrql;\n};\n\nexport default withUrqlClient;","map":{"version":3,"sources":["/Users/rsbear/dev/next-urql/lib/withUrqlClient.tsx"],"names":["React","Provider","cookie","ssrPrepass","initUrqlClient","useAuthUserQuery","isBrowser","withUrqlClient","App","withUrql","props","fetching","error","data","urqlClient","urqlState","serverAccessToken","authUser","me","getInitialProps","ctx","AppTree","req","res","appProps","cookies","parse","headers","rfs","response","fetch","method","credentials","json","accessToken","ssrCache","err","console","log","extractData"],"mappings":"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","sourcesContent":["import React from \"react\";\nimport { Provider } from \"urql\";\nimport cookie from \"cookie\";\n\nimport ssrPrepass from \"react-ssr-prepass\";\nimport initUrqlClient from \"./initUrql\";\nimport { useAuthUserQuery } from \"../generated/graphql\";\n\nconst isBrowser: boolean = typeof window !== \"undefined\";\n\nconst withUrqlClient = App => {\n  const withUrql = props => {\n    const [{ fetching, error, data }] = useAuthUserQuery();\n    const urqlClient =\n      props.urqlClient ||\n      initUrqlClient(props.urqlState, props.serverAccessToken)[0];\n    const authUser = !fetching && data && data.me ? data.me : null;\n    return (\n      <Provider value={urqlClient}>\n        <App {...props} urqlClient={urqlClient} authUser={authUser} />\n      </Provider>\n    );\n  };\n\n  withUrql.getInitialProps = async ctx => {\n    const { AppTree } = ctx;\n    const { req, res } = ctx;\n    // Run the wrapped component's getInitialProps function\n    let appProps = {};\n    if (App.getInitialProps) appProps = await App.getInitialProps(ctx);\n\n    // getInitialProps is universal, but we only want\n    // to run server-side rendered suspense on the server\n    let serverAccessToken = \"\";\n    if (!isBrowser) {\n      const cookies = cookie.parse(\n        req.headers.cookie ? req.headers.cookie : \"\"\n      );\n      if (cookies.rfs) {\n        const response = await fetch(\"http://localhost:4000/refresh_token\", {\n          method: \"POST\",\n          credentials: \"include\",\n          headers: {\n            cookie: \"rfs=\" + cookies.rfs\n          }\n        });\n        const data = await response.json();\n        serverAccessToken = data.accessToken;\n      }\n    }\n\n    if (isBrowser) return appProps;\n\n    const [urqlClient, ssrCache] = initUrqlClient({}, serverAccessToken);\n\n    // Run suspense and hence all urql queries\n\n    try {\n      await ssrPrepass(\n        <AppTree\n          pageProps={{\n            ...appProps,\n            urqlClient\n          }}\n        />\n      );\n    } catch (err) {\n      console.log(err);\n    }\n\n    // Extract query data from the urql store\n    // Extract the SSR query data from urql's SSR cache\n    const urqlState = ssrCache.extractData();\n\n    return {\n      ...appProps,\n      urqlState,\n      serverAccessToken\n    };\n  };\n\n  return withUrql;\n};\n\nexport default withUrqlClient;\n"]},"metadata":{},"sourceType":"module"}